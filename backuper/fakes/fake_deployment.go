// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/pivotal-cf/pcf-backup-and-restore/backuper"
)

type FakeDeployment struct {
	IsBackupableStub        func() (bool, error)
	isBackupableMutex       sync.RWMutex
	isBackupableArgsForCall []struct{}
	isBackupableReturns     struct {
		result1 bool
		result2 error
	}
	IsRestorableStub        func() (bool, error)
	isRestorableMutex       sync.RWMutex
	isRestorableArgsForCall []struct{}
	isRestorableReturns     struct {
		result1 bool
		result2 error
	}
	BackupStub        func() error
	backupMutex       sync.RWMutex
	backupArgsForCall []struct{}
	backupReturns     struct {
		result1 error
	}
	RestoreStub        func() error
	restoreMutex       sync.RWMutex
	restoreArgsForCall []struct{}
	restoreReturns     struct {
		result1 error
	}
	CopyRemoteBackupsToLocalArtifactStub        func(backuper.Artifact) error
	copyRemoteBackupsToLocalArtifactMutex       sync.RWMutex
	copyRemoteBackupsToLocalArtifactArgsForCall []struct {
		arg1 backuper.Artifact
	}
	copyRemoteBackupsToLocalArtifactReturns struct {
		result1 error
	}
	LoadFromStub        func(backuper.Artifact) error
	loadFromMutex       sync.RWMutex
	loadFromArgsForCall []struct {
		arg1 backuper.Artifact
	}
	loadFromReturns struct {
		result1 error
	}
	CleanupStub        func() error
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct{}
	cleanupReturns     struct {
		result1 error
	}
	InstancesStub        func() []backuper.Instance
	instancesMutex       sync.RWMutex
	instancesArgsForCall []struct{}
	instancesReturns     struct {
		result1 []backuper.Instance
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDeployment) IsBackupable() (bool, error) {
	fake.isBackupableMutex.Lock()
	fake.isBackupableArgsForCall = append(fake.isBackupableArgsForCall, struct{}{})
	fake.recordInvocation("IsBackupable", []interface{}{})
	fake.isBackupableMutex.Unlock()
	if fake.IsBackupableStub != nil {
		return fake.IsBackupableStub()
	} else {
		return fake.isBackupableReturns.result1, fake.isBackupableReturns.result2
	}
}

func (fake *FakeDeployment) IsBackupableCallCount() int {
	fake.isBackupableMutex.RLock()
	defer fake.isBackupableMutex.RUnlock()
	return len(fake.isBackupableArgsForCall)
}

func (fake *FakeDeployment) IsBackupableReturns(result1 bool, result2 error) {
	fake.IsBackupableStub = nil
	fake.isBackupableReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) IsRestorable() (bool, error) {
	fake.isRestorableMutex.Lock()
	fake.isRestorableArgsForCall = append(fake.isRestorableArgsForCall, struct{}{})
	fake.recordInvocation("IsRestorable", []interface{}{})
	fake.isRestorableMutex.Unlock()
	if fake.IsRestorableStub != nil {
		return fake.IsRestorableStub()
	} else {
		return fake.isRestorableReturns.result1, fake.isRestorableReturns.result2
	}
}

func (fake *FakeDeployment) IsRestorableCallCount() int {
	fake.isRestorableMutex.RLock()
	defer fake.isRestorableMutex.RUnlock()
	return len(fake.isRestorableArgsForCall)
}

func (fake *FakeDeployment) IsRestorableReturns(result1 bool, result2 error) {
	fake.IsRestorableStub = nil
	fake.isRestorableReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDeployment) Backup() error {
	fake.backupMutex.Lock()
	fake.backupArgsForCall = append(fake.backupArgsForCall, struct{}{})
	fake.recordInvocation("Backup", []interface{}{})
	fake.backupMutex.Unlock()
	if fake.BackupStub != nil {
		return fake.BackupStub()
	} else {
		return fake.backupReturns.result1
	}
}

func (fake *FakeDeployment) BackupCallCount() int {
	fake.backupMutex.RLock()
	defer fake.backupMutex.RUnlock()
	return len(fake.backupArgsForCall)
}

func (fake *FakeDeployment) BackupReturns(result1 error) {
	fake.BackupStub = nil
	fake.backupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Restore() error {
	fake.restoreMutex.Lock()
	fake.restoreArgsForCall = append(fake.restoreArgsForCall, struct{}{})
	fake.recordInvocation("Restore", []interface{}{})
	fake.restoreMutex.Unlock()
	if fake.RestoreStub != nil {
		return fake.RestoreStub()
	} else {
		return fake.restoreReturns.result1
	}
}

func (fake *FakeDeployment) RestoreCallCount() int {
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	return len(fake.restoreArgsForCall)
}

func (fake *FakeDeployment) RestoreReturns(result1 error) {
	fake.RestoreStub = nil
	fake.restoreReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) CopyRemoteBackupsToLocalArtifact(arg1 backuper.Artifact) error {
	fake.copyRemoteBackupsToLocalArtifactMutex.Lock()
	fake.copyRemoteBackupsToLocalArtifactArgsForCall = append(fake.copyRemoteBackupsToLocalArtifactArgsForCall, struct {
		arg1 backuper.Artifact
	}{arg1})
	fake.recordInvocation("CopyRemoteBackupsToLocalArtifact", []interface{}{arg1})
	fake.copyRemoteBackupsToLocalArtifactMutex.Unlock()
	if fake.CopyRemoteBackupsToLocalArtifactStub != nil {
		return fake.CopyRemoteBackupsToLocalArtifactStub(arg1)
	} else {
		return fake.copyRemoteBackupsToLocalArtifactReturns.result1
	}
}

func (fake *FakeDeployment) CopyRemoteBackupsToLocalArtifactCallCount() int {
	fake.copyRemoteBackupsToLocalArtifactMutex.RLock()
	defer fake.copyRemoteBackupsToLocalArtifactMutex.RUnlock()
	return len(fake.copyRemoteBackupsToLocalArtifactArgsForCall)
}

func (fake *FakeDeployment) CopyRemoteBackupsToLocalArtifactArgsForCall(i int) backuper.Artifact {
	fake.copyRemoteBackupsToLocalArtifactMutex.RLock()
	defer fake.copyRemoteBackupsToLocalArtifactMutex.RUnlock()
	return fake.copyRemoteBackupsToLocalArtifactArgsForCall[i].arg1
}

func (fake *FakeDeployment) CopyRemoteBackupsToLocalArtifactReturns(result1 error) {
	fake.CopyRemoteBackupsToLocalArtifactStub = nil
	fake.copyRemoteBackupsToLocalArtifactReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) LoadFrom(arg1 backuper.Artifact) error {
	fake.loadFromMutex.Lock()
	fake.loadFromArgsForCall = append(fake.loadFromArgsForCall, struct {
		arg1 backuper.Artifact
	}{arg1})
	fake.recordInvocation("LoadFrom", []interface{}{arg1})
	fake.loadFromMutex.Unlock()
	if fake.LoadFromStub != nil {
		return fake.LoadFromStub(arg1)
	} else {
		return fake.loadFromReturns.result1
	}
}

func (fake *FakeDeployment) LoadFromCallCount() int {
	fake.loadFromMutex.RLock()
	defer fake.loadFromMutex.RUnlock()
	return len(fake.loadFromArgsForCall)
}

func (fake *FakeDeployment) LoadFromArgsForCall(i int) backuper.Artifact {
	fake.loadFromMutex.RLock()
	defer fake.loadFromMutex.RUnlock()
	return fake.loadFromArgsForCall[i].arg1
}

func (fake *FakeDeployment) LoadFromReturns(result1 error) {
	fake.LoadFromStub = nil
	fake.loadFromReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Cleanup() error {
	fake.cleanupMutex.Lock()
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct{}{})
	fake.recordInvocation("Cleanup", []interface{}{})
	fake.cleanupMutex.Unlock()
	if fake.CleanupStub != nil {
		return fake.CleanupStub()
	} else {
		return fake.cleanupReturns.result1
	}
}

func (fake *FakeDeployment) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeDeployment) CleanupReturns(result1 error) {
	fake.CleanupStub = nil
	fake.cleanupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeployment) Instances() []backuper.Instance {
	fake.instancesMutex.Lock()
	fake.instancesArgsForCall = append(fake.instancesArgsForCall, struct{}{})
	fake.recordInvocation("Instances", []interface{}{})
	fake.instancesMutex.Unlock()
	if fake.InstancesStub != nil {
		return fake.InstancesStub()
	} else {
		return fake.instancesReturns.result1
	}
}

func (fake *FakeDeployment) InstancesCallCount() int {
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	return len(fake.instancesArgsForCall)
}

func (fake *FakeDeployment) InstancesReturns(result1 []backuper.Instance) {
	fake.InstancesStub = nil
	fake.instancesReturns = struct {
		result1 []backuper.Instance
	}{result1}
}

func (fake *FakeDeployment) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.isBackupableMutex.RLock()
	defer fake.isBackupableMutex.RUnlock()
	fake.isRestorableMutex.RLock()
	defer fake.isRestorableMutex.RUnlock()
	fake.backupMutex.RLock()
	defer fake.backupMutex.RUnlock()
	fake.restoreMutex.RLock()
	defer fake.restoreMutex.RUnlock()
	fake.copyRemoteBackupsToLocalArtifactMutex.RLock()
	defer fake.copyRemoteBackupsToLocalArtifactMutex.RUnlock()
	fake.loadFromMutex.RLock()
	defer fake.loadFromMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	fake.instancesMutex.RLock()
	defer fake.instancesMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeDeployment) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ backuper.Deployment = new(FakeDeployment)

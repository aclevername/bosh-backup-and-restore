// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/bosh-backup-and-restore/orchestrator"
)

type FakeJob struct {
	HasBackupStub        func() bool
	hasBackupMutex       sync.RWMutex
	hasBackupArgsForCall []struct{}
	hasBackupReturns     struct {
		result1 bool
	}
	hasBackupReturnsOnCall map[int]struct {
		result1 bool
	}
	PreBackupLockStub        func() error
	preBackupLockMutex       sync.RWMutex
	preBackupLockArgsForCall []struct{}
	preBackupLockReturns     struct {
		result1 error
	}
	preBackupLockReturnsOnCall map[int]struct {
		result1 error
	}
	PostBackupUnlockStub        func() error
	postBackupUnlockMutex       sync.RWMutex
	postBackupUnlockArgsForCall []struct{}
	postBackupUnlockReturns     struct {
		result1 error
	}
	postBackupUnlockReturnsOnCall map[int]struct {
		result1 error
	}
	BackupShouldBeLockedBeforeStub        func() []orchestrator.JobSpecifier
	backupShouldBeLockedBeforeMutex       sync.RWMutex
	backupShouldBeLockedBeforeArgsForCall []struct{}
	backupShouldBeLockedBeforeReturns     struct {
		result1 []orchestrator.JobSpecifier
	}
	backupShouldBeLockedBeforeReturnsOnCall map[int]struct {
		result1 []orchestrator.JobSpecifier
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ReleaseStub        func() string
	releaseMutex       sync.RWMutex
	releaseArgsForCall []struct{}
	releaseReturns     struct {
		result1 string
	}
	releaseReturnsOnCall map[int]struct {
		result1 string
	}
	InstanceIdentifierStub        func() string
	instanceIdentifierMutex       sync.RWMutex
	instanceIdentifierArgsForCall []struct{}
	instanceIdentifierReturns     struct {
		result1 string
	}
	instanceIdentifierReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeJob) HasBackup() bool {
	fake.hasBackupMutex.Lock()
	ret, specificReturn := fake.hasBackupReturnsOnCall[len(fake.hasBackupArgsForCall)]
	fake.hasBackupArgsForCall = append(fake.hasBackupArgsForCall, struct{}{})
	fake.recordInvocation("HasBackup", []interface{}{})
	fake.hasBackupMutex.Unlock()
	if fake.HasBackupStub != nil {
		return fake.HasBackupStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hasBackupReturns.result1
}

func (fake *FakeJob) HasBackupCallCount() int {
	fake.hasBackupMutex.RLock()
	defer fake.hasBackupMutex.RUnlock()
	return len(fake.hasBackupArgsForCall)
}

func (fake *FakeJob) HasBackupReturns(result1 bool) {
	fake.HasBackupStub = nil
	fake.hasBackupReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeJob) HasBackupReturnsOnCall(i int, result1 bool) {
	fake.HasBackupStub = nil
	if fake.hasBackupReturnsOnCall == nil {
		fake.hasBackupReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasBackupReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeJob) PreBackupLock() error {
	fake.preBackupLockMutex.Lock()
	ret, specificReturn := fake.preBackupLockReturnsOnCall[len(fake.preBackupLockArgsForCall)]
	fake.preBackupLockArgsForCall = append(fake.preBackupLockArgsForCall, struct{}{})
	fake.recordInvocation("PreBackupLock", []interface{}{})
	fake.preBackupLockMutex.Unlock()
	if fake.PreBackupLockStub != nil {
		return fake.PreBackupLockStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.preBackupLockReturns.result1
}

func (fake *FakeJob) PreBackupLockCallCount() int {
	fake.preBackupLockMutex.RLock()
	defer fake.preBackupLockMutex.RUnlock()
	return len(fake.preBackupLockArgsForCall)
}

func (fake *FakeJob) PreBackupLockReturns(result1 error) {
	fake.PreBackupLockStub = nil
	fake.preBackupLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) PreBackupLockReturnsOnCall(i int, result1 error) {
	fake.PreBackupLockStub = nil
	if fake.preBackupLockReturnsOnCall == nil {
		fake.preBackupLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.preBackupLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) PostBackupUnlock() error {
	fake.postBackupUnlockMutex.Lock()
	ret, specificReturn := fake.postBackupUnlockReturnsOnCall[len(fake.postBackupUnlockArgsForCall)]
	fake.postBackupUnlockArgsForCall = append(fake.postBackupUnlockArgsForCall, struct{}{})
	fake.recordInvocation("PostBackupUnlock", []interface{}{})
	fake.postBackupUnlockMutex.Unlock()
	if fake.PostBackupUnlockStub != nil {
		return fake.PostBackupUnlockStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.postBackupUnlockReturns.result1
}

func (fake *FakeJob) PostBackupUnlockCallCount() int {
	fake.postBackupUnlockMutex.RLock()
	defer fake.postBackupUnlockMutex.RUnlock()
	return len(fake.postBackupUnlockArgsForCall)
}

func (fake *FakeJob) PostBackupUnlockReturns(result1 error) {
	fake.PostBackupUnlockStub = nil
	fake.postBackupUnlockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) PostBackupUnlockReturnsOnCall(i int, result1 error) {
	fake.PostBackupUnlockStub = nil
	if fake.postBackupUnlockReturnsOnCall == nil {
		fake.postBackupUnlockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.postBackupUnlockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) BackupShouldBeLockedBefore() []orchestrator.JobSpecifier {
	fake.backupShouldBeLockedBeforeMutex.Lock()
	ret, specificReturn := fake.backupShouldBeLockedBeforeReturnsOnCall[len(fake.backupShouldBeLockedBeforeArgsForCall)]
	fake.backupShouldBeLockedBeforeArgsForCall = append(fake.backupShouldBeLockedBeforeArgsForCall, struct{}{})
	fake.recordInvocation("BackupShouldBeLockedBefore", []interface{}{})
	fake.backupShouldBeLockedBeforeMutex.Unlock()
	if fake.BackupShouldBeLockedBeforeStub != nil {
		return fake.BackupShouldBeLockedBeforeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.backupShouldBeLockedBeforeReturns.result1
}

func (fake *FakeJob) BackupShouldBeLockedBeforeCallCount() int {
	fake.backupShouldBeLockedBeforeMutex.RLock()
	defer fake.backupShouldBeLockedBeforeMutex.RUnlock()
	return len(fake.backupShouldBeLockedBeforeArgsForCall)
}

func (fake *FakeJob) BackupShouldBeLockedBeforeReturns(result1 []orchestrator.JobSpecifier) {
	fake.BackupShouldBeLockedBeforeStub = nil
	fake.backupShouldBeLockedBeforeReturns = struct {
		result1 []orchestrator.JobSpecifier
	}{result1}
}

func (fake *FakeJob) BackupShouldBeLockedBeforeReturnsOnCall(i int, result1 []orchestrator.JobSpecifier) {
	fake.BackupShouldBeLockedBeforeStub = nil
	if fake.backupShouldBeLockedBeforeReturnsOnCall == nil {
		fake.backupShouldBeLockedBeforeReturnsOnCall = make(map[int]struct {
			result1 []orchestrator.JobSpecifier
		})
	}
	fake.backupShouldBeLockedBeforeReturnsOnCall[i] = struct {
		result1 []orchestrator.JobSpecifier
	}{result1}
}

func (fake *FakeJob) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nameReturns.result1
}

func (fake *FakeJob) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeJob) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) Release() string {
	fake.releaseMutex.Lock()
	ret, specificReturn := fake.releaseReturnsOnCall[len(fake.releaseArgsForCall)]
	fake.releaseArgsForCall = append(fake.releaseArgsForCall, struct{}{})
	fake.recordInvocation("Release", []interface{}{})
	fake.releaseMutex.Unlock()
	if fake.ReleaseStub != nil {
		return fake.ReleaseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.releaseReturns.result1
}

func (fake *FakeJob) ReleaseCallCount() int {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	return len(fake.releaseArgsForCall)
}

func (fake *FakeJob) ReleaseReturns(result1 string) {
	fake.ReleaseStub = nil
	fake.releaseReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) ReleaseReturnsOnCall(i int, result1 string) {
	fake.ReleaseStub = nil
	if fake.releaseReturnsOnCall == nil {
		fake.releaseReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.releaseReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) InstanceIdentifier() string {
	fake.instanceIdentifierMutex.Lock()
	ret, specificReturn := fake.instanceIdentifierReturnsOnCall[len(fake.instanceIdentifierArgsForCall)]
	fake.instanceIdentifierArgsForCall = append(fake.instanceIdentifierArgsForCall, struct{}{})
	fake.recordInvocation("InstanceIdentifier", []interface{}{})
	fake.instanceIdentifierMutex.Unlock()
	if fake.InstanceIdentifierStub != nil {
		return fake.InstanceIdentifierStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.instanceIdentifierReturns.result1
}

func (fake *FakeJob) InstanceIdentifierCallCount() int {
	fake.instanceIdentifierMutex.RLock()
	defer fake.instanceIdentifierMutex.RUnlock()
	return len(fake.instanceIdentifierArgsForCall)
}

func (fake *FakeJob) InstanceIdentifierReturns(result1 string) {
	fake.InstanceIdentifierStub = nil
	fake.instanceIdentifierReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) InstanceIdentifierReturnsOnCall(i int, result1 string) {
	fake.InstanceIdentifierStub = nil
	if fake.instanceIdentifierReturnsOnCall == nil {
		fake.instanceIdentifierReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.instanceIdentifierReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.hasBackupMutex.RLock()
	defer fake.hasBackupMutex.RUnlock()
	fake.preBackupLockMutex.RLock()
	defer fake.preBackupLockMutex.RUnlock()
	fake.postBackupUnlockMutex.RLock()
	defer fake.postBackupUnlockMutex.RUnlock()
	fake.backupShouldBeLockedBeforeMutex.RLock()
	defer fake.backupShouldBeLockedBeforeMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	fake.instanceIdentifierMutex.RLock()
	defer fake.instanceIdentifierMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeJob) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ orchestrator.Job = new(FakeJob)
